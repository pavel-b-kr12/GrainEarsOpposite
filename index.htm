<!DOCTYPE html>
<html>
  <head>
    <title>Default .babylon loading scene</title><link rel="icon" href="data:,">
    <meta charset="UTF-8" />
    <!-- this link to the preview online version of BJS -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script> 
    <!-- this is needed for BJS to load scene files -->
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        color: white;
      }
      #canvas {
        width: 90%;
        height: 90%;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script type="text/javascript">
		var tx="  _ [draft v03] grain ears opposite \w ost, kr12, Куинджи"
		var earsE=404;
		
      var canvas = document.getElementById("canvas");
      var engine = new BABYLON.Engine(canvas, true);
	  var sc=null;
	  var bFirstFrame=true;
	  var ee=[];
	  var eeZ=[];
	  
	  BABYLON.Animation.AllowMatricesInterpolation = true
      // doc.babylonjs.com/typedoc/classes/babylon.sceneloader#load
      BABYLON.SceneLoader.Load("", "sc.babylon", engine, function (scene) {
      //BABYLON.SceneLoader.Load("", "ear_b02invc.babylon", engine, function (scene) {
        var camera = new BABYLON.ArcRotateCamera("Camera", 1.3, 1.5, 7, BABYLON.Vector3.Zero(), scene);
		camera.wheelPrecision = 60; 
		
		
        camera.attachControl(canvas, false);
        scene.clearColor = new BABYLON.Color3(0, 0, 0.2);
        scene.ambientColor = new BABYLON.Color3.White();
		sc=scene;
		
					// Create the 3D UI manager
		manager = new BABYLON.GUI.GUI3DManager(sc);
		//panel.margin = 0.75;
		//manager.addControl(panel);
		//panel.linkToTransformNode(anchor);
		//panel.position.z = -2;
		

    BABYLON.SceneLoader.ImportMesh("", "", "pushButton.glb", scene, function (newMeshes) {
        pushButtonCore = newMeshes[0];
        makePushButtons();
        pushButtonCore.setEnabled(false);
    });
	
	//Creation of a repeated textured material
    materialPlane = new BABYLON.StandardMaterial("texturePlane", scene);
    materialPlane.diffuseTexture = new BABYLON.Texture("Kuindzhi_Ukrainian_night_1876.jpg", scene);
	//materialPlane.emissiveColor = new BABYLON.Color3(1, 1, 1);
    materialPlane.alpha = 0.9;
	//Creation of a plane
    plane = BABYLON.Mesh.CreatePlane("plane", 4, scene);
	plane.scaling.x=1.5;
	plane.rotation.y = Math.PI;
	
	plane.position.z=-5;
	plane.position.y=0.5
	plane.position.z=-1.35
	
	sc.lights[0].range=5
	//sc.lights[1].intensity=2
	//sc.lights[1].position.z=14
	sc.lights[2].range=5
    
    plane.material = materialPlane;
	//plane.disableLighting = true;
	//materialPlane.disableLighting = true;
	// var light = new BABYLON.PointLight("Omni", new BABYLON.Vector3(-60, 60, 80), scene);
	
	
	//-------------
	var gl = new BABYLON.GlowLayer("glow", scene);

var makeBeerText = function(text, board, neoncolor){ //TODO multiline BABYLON.GUI.TextBlock https://playground.babylonjs.com/#ZI9AK7#908 
	const plane = BABYLON.Mesh.CreatePlane('', 25, scene);
	plane.material = new BABYLON.StandardMaterial('', scene);
    
	const texture = new BABYLON.DynamicTexture('', 812, scene, true);

    const context = texture.getContext();
    const fontSize = 20
    const lineHeight = fontSize * 1.486;
    const ad = text
    context.fillStyle = 'white';
    context.font = ""+fontSize+"px Apple Chancery";
    const textWidth = context.measureText(ad).width*1.1;
    var BeerCanvas = {
        width: context.measureText(ad).width,
        height: fontSize
    }
    
    if(board){
        context.lineWidth = 11;
        roundRect(context, 0, 0, textWidth, lineHeight, {
    tl: 50,
    br: 25
    }, false);
    }else{
        context.fillText(ad, 0, BeerCanvas.height);
    }
    texture.update();

	plane.material.opacityTexture = texture;
	plane.material.emissiveColor = neoncolor;
    //plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
	plane.material.backFaceCulling = false;//Allways show the front and the back of an element
    plane.position.x = -9;
    plane.position.y = -15.5;
    plane.position.z = -1;
	plane.rotation.y = Math.PI;
   return plane;
}

var beertext = new makeBeerText(tx, false, new BABYLON.Color3(0, 1, 0.38))
var beertext_Board = new makeBeerText(tx, true, new BABYLON.Color3(0.98, 1, 0))

scene.registerBeforeRender(()=>{
//beertext_Board.material.emissiveColor.r = (Math.random()*(1+.5))-.5
})
	//-------------
	
		
	sc.onPointerObservable.add(function(evt){
        if(evt.pickInfo.hit && evt.pickInfo.pickedMesh && evt.event.button === 0){
            selectedMesh = evt.pickInfo.pickedMesh;
			//console.log(selectedMesh, selectedMesh.name)
			if(selectedMesh.name=="screwR") { screwAnim.push(selectedMesh); selectedMesh.animend=performance.now()+2000;}
			if(selectedMesh.name=="screwL") { screwAnim.push(selectedMesh); selectedMesh.animend=performance.now()+2000;}
        }
    }, BABYLON.PointerEventTypes.POINTERUP);
		
		//--------------------------------------
        engine.runRenderLoop(function () {
          scene.render();
		  if(bFirstFrame)
		  {
			bFirstFrame=false;
			for(let i=1;i<earsE;i++)
			{
				ee[i]=sc.getMeshByName("ear."+i.toString().padStart(3, "0"));
				eeZ[i]=ee[i].position.y;
			}
		  }
		  
		  //sc.animationGroups[0].play(true);
		  if(screwAnim.length>0)
		  {
		    if(performance.now()<screwAnim[0].animend)
			{
				screwAnim[0].position.z+=0.01;
				screwAnim[0].rotate(new BABYLON.Vector3(0, 1, 0), -0.02);
				//TODO anim screw fall
			}
			else
			{
				screwAnim[0].visibility=false; 
				screwAnim.shift();
				if(screwAnim.length>0) screwAnim[0].animend=performance.now()+1500;
				screws--;
				if(screws==0) sc.getMeshByName("case.front").visibility=false;
			}
		  }
 
  
			if(bPlaying)
			{
				let animScale=1;
				if(performance.now()<animScale_full_t)
					animScale = 1-(animScale_full_t-performance.now())/2000;

			  for(let i=1;i<earsE;i++)
				ee[i].position.y=eeZ[i]+Math.sin(performance.now()/2000.+i*i)*0.09*animScale;//0.2
			}
        });
        window.addEventListener("resize", function () {  engine.resize(); });

      });

	var selectedMesh = null;
	  var currentMesh=null;
	  var screws=2;
	  var screwAnim=[];
	  
	  var bPlaying=false;
	  function play()
	  {
	  
		if(bPlaying)
		{
		document.getElementById('aud').pause();
		bPlaying=false;
		}
		else
		{
			document.getElementById('aud').play();
			bPlaying=true;
			sc.getSkeletonByName('Armature').beginAnimation("do1", true);
			animScale_full_t=performance.now()+2000;
		}
	  }


function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
  if (typeof stroke === 'undefined') {
    stroke = true;
  }
  if (typeof radius === 'undefined') {
    radius = 5;
  }
  if (typeof radius === 'number') {
    radius = {tl: radius, tr: radius, br: radius, bl: radius};
  } else {
    var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
    for (var side in defaultRadius) {
      radius[side] = radius[side] || defaultRadius[side];
    }
  }
  ctx.beginPath();
  ctx.moveTo(x + radius.tl, y);
  ctx.lineTo(x + width - radius.tr, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
  ctx.lineTo(x + width, y + height - radius.br);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
  ctx.lineTo(x + radius.bl, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
  ctx.lineTo(x, y + radius.tl);
  ctx.quadraticCurveTo(x, y, x + radius.tl, y);
  ctx.closePath();
  if (fill) {
    ctx.fill();
  }
  if (stroke) {
    ctx.stroke();
  }

}

var pushButtonCore;
var index = 0; 
var anchor = new BABYLON.TransformNode("");
var manager = null;
//var panel = new BABYLON.GUI.CylinderPanel();

    function makePushButton(mesh, hoverColor) {
        var cylinder = mesh.getChildMeshes(false, (node) => { return node.name.indexOf("Cylinder") !== -1 })[0];
        var cylinderMat = cylinder.material.clone();
        cylinderMat.albedoColor = new BABYLON.Color3(0.5, 0.19, 0);
        cylinder.material = cylinderMat;
        var pushButton = new BABYLON.GUI.MeshButton3D(mesh, "pushButton" + index);
        pushButton.pointerEnterAnimation = () => {
            cylinder.material.albedoColor = hoverColor;
        };
        pushButton.pointerOutAnimation = () => {
             cylinder.material.albedoColor = new BABYLON.Color3(0.5, 0.19, 0);
        };
        pushButton.pointerDownAnimation = () => {
            cylinder.position.y = 0;
			cylinder.material.albedoColor = new BABYLON.Color3(0.7, 1, 0.9);
			play();
        }
        pushButton.pointerUpAnimation = () => {
            cylinder.position.y = 0.21;
			cylinder.material.albedoColor = hoverColor;
        }
        pushButton.onPointerDownObservable.add(() => {
            //console.log(pushButton.name + " pushed.");
        });
		
        //panel.addControl(pushButton);
		pushButton.linkToTransformNode(anchor);
        manager.addControl(pushButton);
        index++;
    }

var btnPlay=null;
    function makePushButtons() {
       var colors = [{r: 0.25, g:0, b:0}, {r: 0, g:0.25, b:0}, {r: 0, g:0, b:0.25},
                      {r: 0.25, g:0.25, b:0}, {r: 0, g:0.25, b:0.25}, {r: 0.25, g:0, b:0.25}];

btnPlay = pushButtonCore.clone("pushButton" + index);
let hoverColor = new BABYLON.Color3(0.2, 1, 0.5);
makePushButton(btnPlay, hoverColor);
btnPlay.position = new BABYLON.Vector3(3.3,-0.2, 2.1);
btnPlay.scaling = new BABYLON.Vector3(0.22,0.22, 0.22);
/*
btnPlay.rotation.x=14;
btnPlay.rotation.y=112;
btnPlay.rotation.z=221;
*/
btnPlay.rotate(new BABYLON.Vector3(0, 1, 0), 3.14);


        //panel.blockLayout = true;
		/*
        for (var i = 0; i < 1; i++)
		{
            newPushButton = pushButtonCore.clone("pushButton" + index);
            let hoverColor = new BABYLON.Color3(colors[i % 6].r, colors[i % 6].g, colors[i % 6].b);
            makePushButton(newPushButton, hoverColor);
        }*/
        //panel.blockLayout = false;

		
		p=sc.getMeshByName("Cube").clone();
		p.position.x+=1;
		p.rotate(new BABYLON.Vector3(0, 1, 0), 1.14);
		
		p1=sc.getMeshByName("Cube").clone();
		p1.position.x-=1;
		p1.rotate(new BABYLON.Vector3(0, 1, 0), 2.14);
		
		//cap=sc.getMeshByName("Cube.001").clone();
		//cap.position.y=-1.1
		//cap.rotate(new BABYLON.Vector3(0, 1, 0), 3.14/2);
					
			//sc.getMeshByName("screwR").
			//Armature
    }
	  
    </script>
	
<audio id="aud">
    <source src="2021-03-20ua.opus" >
</audio>
  </body>
</html>